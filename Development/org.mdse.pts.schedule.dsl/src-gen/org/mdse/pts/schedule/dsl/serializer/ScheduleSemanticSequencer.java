/*
 * generated by Xtext 2.21.0
 */
package org.mdse.pts.schedule.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mdse.pts.schedule.DateTime;
import org.mdse.pts.schedule.FinalSpot;
import org.mdse.pts.schedule.MiddleSpot;
import org.mdse.pts.schedule.Route;
import org.mdse.pts.schedule.Schedule;
import org.mdse.pts.schedule.SchedulePackage;
import org.mdse.pts.schedule.StartSpot;
import org.mdse.pts.schedule.Time;
import org.mdse.pts.schedule.TrainSchedule;
import org.mdse.pts.schedule.dsl.services.ScheduleGrammarAccess;

@SuppressWarnings("all")
public class ScheduleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ScheduleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SchedulePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SchedulePackage.DATE_TIME:
				sequence_DateTime(context, (DateTime) semanticObject); 
				return; 
			case SchedulePackage.FINAL_SPOT:
				sequence_FinalSpot(context, (FinalSpot) semanticObject); 
				return; 
			case SchedulePackage.MIDDLE_SPOT:
				sequence_MiddleSpot(context, (MiddleSpot) semanticObject); 
				return; 
			case SchedulePackage.ROUTE:
				sequence_Route(context, (Route) semanticObject); 
				return; 
			case SchedulePackage.SCHEDULE:
				sequence_Schedule(context, (Schedule) semanticObject); 
				return; 
			case SchedulePackage.START_SPOT:
				sequence_StartSpot(context, (StartSpot) semanticObject); 
				return; 
			case SchedulePackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case SchedulePackage.TRAIN_SCHEDULE:
				sequence_TrainSchedule(context, (TrainSchedule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     DateTime returns DateTime
	 *
	 * Constraint:
	 *     (weekday+=WeekDays weekday+=WeekDays* time=Time)
	 */
	protected void sequence_DateTime(ISerializationContext context, DateTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FinalSpot returns FinalSpot
	 *
	 * Constraint:
	 *     (station=STRING platform=STRING?)
	 */
	protected void sequence_FinalSpot(ISerializationContext context, FinalSpot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MiddleSpot returns MiddleSpot
	 *
	 * Constraint:
	 *     (station=STRING platform=STRING? waitingTime=INT? turnStation?='and turn'? leg=[Leg|ID]?)
	 */
	protected void sequence_MiddleSpot(ISerializationContext context, MiddleSpot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Route returns Route
	 *
	 * Constraint:
	 *     (startSpot=StartSpot middleSpots+=MiddleSpot* finalSpot=FinalSpot)
	 */
	protected void sequence_Route(ISerializationContext context, Route semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Schedule returns Schedule
	 *
	 * Constraint:
	 *     (network=[Network|ID] depots+=[Depot|ID] depots+=[Depot|ID]* trainSchedules+=TrainSchedule*)
	 */
	protected void sequence_Schedule(ISerializationContext context, Schedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StartSpot returns StartSpot
	 *
	 * Constraint:
	 *     (station=STRING platform=STRING? leg=[Leg|ID]?)
	 */
	protected void sequence_StartSpot(ISerializationContext context, StartSpot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (hours=INT minutes=INT)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchedulePackage.Literals.TIME__HOURS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulePackage.Literals.TIME__HOURS));
			if (transientValues.isValueTransient(semanticObject, SchedulePackage.Literals.TIME__MINUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchedulePackage.Literals.TIME__MINUTES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getHoursINTTerminalRuleCall_0_0(), semanticObject.getHours());
		feeder.accept(grammarAccess.getTimeAccess().getMinutesINTTerminalRuleCall_2_0(), semanticObject.getMinutes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrainSchedule returns TrainSchedule
	 *
	 * Constraint:
	 *     (train=[Train|ID] dateTimes+=DateTime (dateTimes+=DateTime* dateTimes+=DateTime)? route=Route)
	 */
	protected void sequence_TrainSchedule(ISerializationContext context, TrainSchedule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
